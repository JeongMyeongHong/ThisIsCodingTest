package com.example.thisiscodingtest.part02.ch4;

import java.util.Scanner;

/**
 * packageName   :   com.example.thisiscodingtest.part02.ch4
 * fileName      :   Implementation
 * author        :   JeongmyeongHong
 * date          :   2022-02-26
 * desc          :  머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정.
 *                  구현 문제 유형은 모든 범위의 코딩테스트 문제 유형을 포함하는 개념이다.
 *                  알고리즘 교재들에서는 대부분 구현을 별도의 유형으로 다루지 않는다.
 *
 * ============================================
 * DATE             AUTHOR              NOTE
 * ============================================
 * 2022-02-26      JeongmyoengHong     최초 생성
 */
public interface Implementation {

    void lrud(Scanner scanner);
    /**
     * 상하좌우 (110p)
     * N * N 크기의 정사각형 공간위에 서있다.
     * 가장 왼쪽 위 좌표는 (1,1) 가장 오른쪽 좌표는 (N,N)이다.
     * 상하좌우로 이동 가능하며 시작좌표는 (1,1)이다.
     * 주어진 계획서 대로 이동한다. (ex_ R R R U D D)
     * 만약 이동방향이 지도 밖으로 되어있다면 무시된다.
     * 최종 도착할 지점의 좌표를 출력해라.
     *
     * 입력조건 1. 공간의 크기 N을 입력한다. (N은 1~100)
     *        2. 이동할 계획서의 내용을 입력한다. (이동횟수는 1~100)
     *      ex) 5
     *          R R R U D D
     * 출력조건 1. 도착할 지점의 좌표를 공백으로 구분하여 출력한다.
     *      ex) 3 4
     * */

    void time(Scanner scanner);
    /**
     * 시각(113p)
     * 정수 N이 입력되면 00시00분00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구해라.
     * 예를들어 1을 입력한다면
     * 00시00분00초부터 01시 59분 59초까지의 경우의 수를 구한다.
     * 00시00분03초, 00시00분13초,.....01시 30분 00초....
     *
     * 입력조건 1. 정수 N이 입력된다. (0~23)
     *      ex) 5
     * 출력조건 1. 모든 경우의 수의 갯수를 출력한다.
     *      ex) 11475
     * */

    void knight(Scanner scanner);
    /**
     * 왕실의 나이트(115p)
     * 8 * 8 크기의 공간이 있다.
     * 나이트는 특정한 한칸에 위치해있다.
     * 이동을 할 때에는 L자 형태로만 이공할 수 있으며 공간 밖으로는 이동 할 수 없다.
     * 나이트의 이동은 수평수평수직 또는 수직수직수평 으로만 이동 할 수 있다.
     * 행의 위치는 1~8, 열의 위치는 a~h로 표현한다.
     * 만약 나이트의 위치가 a1이라면 나이트의 이동 경로는 c2와 b3으로 두가지 이다.
     * 만약 나이트의 위치가 c2라면 이동경로는 6가지이다.
     *
     * 입력조건 1. 현재 나이트가 위치한 곳의 좌표를 나타내는 문자를 입력받는다.
     *      ex) a1
     * 출력조건 1. 나이트가 이동할 수 있는 경우의 수를 출력한다.
     *      ex) 2
     * */

    void devGame(Scanner scanner);
    /**
     * 게임 개발(118p)
     * N * M 크기의 공간이 있다. 각 칸은 육지 또는 바다이다.
     * 캐릭터는 동서남북중 한곳을 바라보고 있다.
     * 맵의 각 칸은 (A, B)로 나타내며 A는 북쪽으로부터 떨어진 칸의 수, B는 서쪽으로부터 떨어진 칸의 수이다.
     * 상하좌우로 움직일 수 있고 바다로 되어있는 공간에는 갈 수 없다.
     * 캐릭터의 움직임을 설정하기 위해 정해놓은 매뉴얼은 아래와 같다.
     * 1. 현재 위치에서 현재 방향을 기준으로 왼쪽방향(반시계 방향으로 90도 회전)부터 차례대로 갈 곳을 정한다.
     * 2. 캐릭터의 바로 왼쪽 방향에 아직 가보지 안ㄶ은 칸이 존재한다면, 왼쪽방향으로 회전한 다음 왼쪽으로 한 칸을 전진한다.
     *    왼쪽 방향에 가보지 않은 칸이 없다면 왼쪽방향으로 회전만 한 후 1단계로 돌아간다.
     * 3. 만약 네 방향 모두 이미 가본 칸이거나 바다인경우, 바라보는 방향을 유지한 채로 한칸 뒤로 이동 후 1단계로 돌아간다.
     *    이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없을 경우에는 움직임을 멈춘다.
     *
     * (책과는 다른 입력조건)
     * 입력조건 1. 공간의 크기 (세로 N, 가로 M)에 3~50 사이의 랜덤숫자를 할당한다.
     *        2. 맵의 정보를 입력한다.(맵의 크기만큼 0(육지),1(바다) 랜덤으로 할당한다.)
     *           맵의 외각은 항상 바다로 되어있다.
     *        3. 캐릭터가 있는 칸의 좌표 (A, B)와 바라보고 있는 방향 d를 각각 공백으로 입력한다. (0-북, 1-동, 2-남, 3-서)
     *           (공백으로 구분하기 힘들다면 엔터로 구분)
     *           게임 캐릭터의 최초 위치는 항상 육지이다.
     *       ex) N,M은 랜덤.   N=5, M=6
     *           맵의 정보는 랜덤.
     *                1 1 1 1 1 1
     *                1 1 0 1 0 1
     *                1 0 0 0 1 1
     *                1 1 0 0 0 1
     *                1 1 1 1 1 1
     *           캐틱터의 생성 좌표 및 방향 ( (1,1) 에 북쪽을 바라본다.)
     *                1 1 0
     * 출력조건 1. 이동을 마친 후 캐릭터가 방문한 칸의 수를 출력한다.
     *      ex) 3
     * */
}
